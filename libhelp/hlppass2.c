/*****************************************************************************
** FILE NAME:       pass2.c
**
** DESCRIPTION:     Second Pass Through Source Help File
**                  Generate All Output Files
**
** static void     Terminate_Line (void);
** static void     Flush_Word (void);
** static void     Write_Space (void);
** static void     Scan_Text (void);
** void     Pass2 (void);
**
******************************************************************************
** REVISION HISTORY:
**   Sun Jun 18, 1989 - initiated by Ken Broomfield
**
**  8/14/89     KWB     Added hypertext linkage capability.
**
*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "hlpmgrif.h"
#include "hlpbld.h"
#include "hlppass1.h"
#include "hlppass2.h"
#include "hlpsymbol.h"

#ifndef SEEK_SET
#define	SEEK_SET	0
#endif

/******************************************************************************
**          FORWARD FUNCTION DECLARATIONS (GENERATED BY MM.EXE)
******************************************************************************/
static void     Terminate_Line (void);
static void     Flush_Word (void);
static void     Write_Space (void);
static void     Scan_Text (void);
void     Pass2 (void);
/******************************************************************************
**        END OF FORWARD FUNCTION DECLARATIONS (GENERATED BY MM.EXE)
******************************************************************************/

/*****************************************************************************
**                                 Constants
*****************************************************************************/

/*
**  Line size fudge factor:
**  This is the number of bytes in a line of help text that must remain
**  available in order for the line to be terminated correctly (i.e.
**  to accommodate an escape sequence and a zero terminator)
*/

#define LINE_FUDGE      3


/*****************************************************************************
**                                Global Data
*****************************************************************************/


/*
**  Help topic variables
*/

static HELP_TOPIC   Topic;          /* current help topic descriptor block */

/*
**  Text scanner variables
*/

/* The current help text */

static long     Text_Bytes;         /* size of help text in bytes */
static int     Parastart;          /* we're at the start of a paragraph */

/* The current line */

static int      Line_Size;          /* displayed size of current line */
static int      Line_Bytes;         /* bytes in current line */

/* The current word */

static unsigned char     Word [WIN_HELP_MAX_LINE_BYTES]; /* current word */
static int      Word_Size;          /* displayed size of current word */
static int      Word_Bytes;         /* bytes in current word */

/*
**  Hilighting modes:
**      0 = no hilighting,
**      1 = \s: regular hiliting (EAS1),
**      2 = \l: help topic link (EAS2),
**      3 = \l: glossary topic link (EAS3)
*/

static int      Pre_Hilight;        /* mode in effect at the start of the
                                       current word */
static int      Post_Hilight;       /* mode in effect at the end of the
                                       current word (the mode most recently
                                       read from the source file) */


/*.
******************************************************************************
**
**  function -  Terminate_Line:
**
**  desc -      Terminate the current line of text
**
**  entry -
**
**  exit -      globals:
**              Line_Size,
**              Line_Bytes          reset
**
**  notes -     I assume that the line is no larger than
**              WIN_HELP_MAX_LINE_BYTES - 1 so that the terminator can
**              be accommodated.
**
******************************************************************************
*/

static void     Terminate_Line (void)

{
	static unsigned char escstr[] = EAS0;

	/*
    **  Write a zero - line terminator - to the help file
    */

	fwrite ("\000", 1, 1, Help_File);
	HELP_FILE_CHECK;
	++Text_Bytes;

	/*
    **  Reset line variables, update line count
    */

	Line_Size = 0;
	Line_Bytes = 0;
	++Topic.text_lines;

	/*
    **  If we are hilighting text, add the appropriate escape sequence
    **  to the beginning of the line.  Use the pre-hilight mode because
    **  there may be a current word pending.
    */

	if (Pre_Hilight > 0)
	{
		escstr [1] = (unsigned char) (WIN_ESC_EAS_LO + Pre_Hilight);
		fwrite (escstr, 2, 1, Help_File);
		HELP_FILE_CHECK;
		Line_Bytes += 2;
		Text_Bytes += 2;
	}
} /* Terminate_Line */


/*.
******************************************************************************
**
**  function -  Flush_Word:
**
**  desc -      Write the current word, if any, to the help file
**
**              Wrap the word to the start of the next line as
**              necessary
**
**  entry -
**
**  exit -
**
**  notes -
**
******************************************************************************
*/

static void     Flush_Word (void)

{
	/*
    **  If the word is empty, forget all this
    */

	if (Word_Bytes == 0)
		return;

	/*
    **  If there isn't enough room on the current line for this word
    **  (either in displayed size or in raw bytes), try to terminate
    **  the current line
    */

	while (Line_Size + Word_Size > WIN_HELP_MAX_LINE  ||
	    Line_Bytes + Word_Bytes > WIN_HELP_MAX_LINE_BYTES - LINE_FUDGE)
	{
		/*
        **  If the current line is already empty, cough, burp, and croak
        **  because the word is just too damn long
        */

		if (Line_Size == 0)
		{
			fprintf (stderr, "(%d) Error - Word exceeds maximum size: '%s'\n",
			    Line_Number, Word);
			exit (-1);
		}

		/*
        **  If this word begins with an EAS0 sequence (which terminates
        **  hilighted strings and topic links), don't wrap it to the
        **  next line with the word
        */

		if (Word_Bytes >= 2  &&  Word [0] == WIN_ESC_CHAR  &&
		    Word [1] == WIN_ESC_EAS_LO + 0)
		{
			fwrite (Word, 2, 1, Help_File);
			HELP_FILE_CHECK;
			Text_Bytes += 2;

			strcpy ((char *)Word, (char *)Word + 2);
			Word_Bytes -= 2;

			Pre_Hilight = 0;
		}

		Terminate_Line ();
	}

	/*
    **  Write out the word and update counts
    */

	fwrite (Word, Word_Bytes, 1, Help_File);
	HELP_FILE_CHECK;
	Line_Size += Word_Size;
	Line_Bytes += Word_Bytes;
	Text_Bytes += Word_Bytes;

	/*
    **  Clear the current word
    */

	Word_Bytes = Word_Size = 0;

	/*
    **  Since the current word is now empty, the pre-hilight mode gets
    **  set to the post-hilight mode
    */

	Pre_Hilight = Post_Hilight;
} /* Flush_Word */


/*.
******************************************************************************
**
**  function -  Write_Space:
**
**  desc -      Write a space character to the help file
**
**  entry -
**
**  exit -
**
**  notes -
**
******************************************************************************
*/

static void     Write_Space (void)

{
	/*
    **  If we're at either the maximum displayed line size or the maximum
    **  line bytes, terminate the line
    */

	if (Line_Size == WIN_HELP_MAX_LINE  ||
	    Line_Bytes == WIN_HELP_MAX_LINE_BYTES - LINE_FUDGE)
		Terminate_Line ();

	/*
    **  If we're at the beginning of a paragraph, or NOT at the beginning
    **  of a line, write out the space
    */

	if (Parastart  ||  Line_Size > 0)
	{
		fwrite (" ", 1, 1, Help_File);
		HELP_FILE_CHECK;
		++Line_Size;
		++Line_Bytes;
		++Text_Bytes;
	}
} /* Write_Space */


/*.
******************************************************************************
**
**  function -  Scan_Text:
**
**  desc -      Scan a topic's title and explanatory text and
**              write it to the help file
**
**  entry -     globals:
**              Topic               ptr to help topic block
**              Source_File         points to start of help text
**              Help_File           points to offset where help text should
**                                  be written
**
**  exit -      globals:
**              Topic.text_lines   set
**              Source_File         points to end of source text
**              Help_File           points to end of help text
**
**  notes -     If an error occurs, a message is displayed and the program
**              terminates.
**
**              This function is a graphic illustration of the axiom,
**              "If it was hard to write, it should be hard to understand."
**
******************************************************************************
*/

static void     Scan_Text (void)

{
	int      c;                  /* source character */
	int     eot;                /* end of text reached */
	int     escape;             /* escape character scanned */
	int     period;
	int     ignore;             /* ignore sequence */
	unsigned char        symbol [MAX_SYMBOL];
	unsigned char        linebuf [MAX_SOURCE_LINE];
	unsigned char        *symptr;
	unsigned    topic;
	TOPSYM      *topsym;
	int         len;

	/*
    **  Initialize
    */

	Text_Bytes = 0;
	Parastart = TRUE;
	Word_Size = 0;
	Word_Bytes = 0;
	Line_Size = 0;
	Line_Bytes = 0;
	Pre_Hilight = 0;
	Post_Hilight = 0;

	escape = FALSE;
	eot = FALSE;
	ignore = FALSE;

	Topic.text_lines = 0;

	/*
    **  Read the title line, truncate it as necessary, and write
    **  it to the help file
    **  (Note: Any error cases would already have been found in pass 1.)
    */

	len = Get_Source_Line (linebuf);
	if (len + 1 > WIN_HELP_MAX_TITLE)
	{
		len = WIN_HELP_MAX_TITLE - 1;
		linebuf [len] = 0;
	}
	fwrite (linebuf, len + 1, 1, Help_File);
	Text_Bytes += len + 1;
	HELP_FILE_CHECK;

	/*
    **  Read help text one character at a time
    */

	while (!eot)
	{
		c = Get_Source_Char ();
		if (c == EOF)
		{
			fprintf (stderr,
				"\n(%d) Warning - End of source file reached, no \\e\n",
			    Line_Number);
			return;
		}

		/*
        **  If we just scanned a backslash, this is the second character
        **  of an escape sequence
        */

		if (escape)
		{
			switch (toupper (c))
			{
				/*
	            **  Ignore sequence
	            */

			case 'I':
				ignore = ! ignore;
				break;

				/*
	            **  End of paragraph marker
	            */

			case '\n':
				/*
                **  Write out the current word, if any, and terminate the line
                */

				Flush_Word ();
				Terminate_Line ();

				/*
                **  We're starting a new paragraph
                */

				Parastart = TRUE;
				break;

				/*
	            **  End of text marker
	            */

			case 'E':
				/*
                **  Write out the current word, if any, and terminate the
                **  line unless it has already been terminated
                */

				Flush_Word ();
				if (Line_Size > 0)
					Terminate_Line ();

				/*
                **  Set flag to terminate scan
                */

				eot = TRUE;
				break;

				/*
	            **  Hilight character
	            */

			case 'C':
				/*
                **  If we're already hilighting text, never mind
                */

				if (Post_Hilight != 0)
					break;

				/*
                **  Add an escape sequence to change the attribute for
                **  the next character (EAC1) to the current word.
                */

				Word [Word_Bytes++] = WIN_ESC_CHAR;
				Word [Word_Bytes++] = WIN_ESC_EAC_LO + 1;
				break;

				/*
	            **  Topic link
	            */

			case 'L':
				/*
                **  If we're already in a topic link, this is the terminator
                */

				if (Post_Hilight > 1)
				{
					/*
                    **  Add an EAS0 sequence to the current word
                    */

					Word [Word_Bytes++] = WIN_ESC_CHAR;
					Word [Word_Bytes++] = WIN_ESC_EAS_LO + 0;

					Post_Hilight = 0;
				}

				/*
                **  Otherwise, this is the start of a topic link
                */

				else
				{
					/*
                    **  Read the symbolic topic name, terminated by a ':'
                    */

					symptr = symbol;
					while ((c = Get_Source_Char ()) != ':')
					{
						if (c == EOF)
						{
							fprintf (stderr,
								"(%d) Error - Unexpected end of file\n",
							    Line_Number);
							exit (-1);
						}
						if (c != ' ')
						{
							if (symptr - symbol < MAX_SYMBOL - 1)
								*symptr++ = (unsigned char) c;
						}
					}
					*symptr = 0;

					/*
                    **  Look up the index of this topic and see if it's a
                    **  glossary topic
                    */

					topsym = Lookup_Symbol ((unsigned char *)symbol);
					if (topsym == (TOPSYM *)NULL)
					{
						fprintf (stderr,
							"\n(%d) Warning - Undefined topic in link ",
						    Line_Number);
						fprintf (stderr, "sequence: %s\n", symbol);
						topic = WIN_HELP_INDEX_TOPIC;
						Post_Hilight = 2;
					}
					else
					{
						topic = topsym->index;
						if (topsym->flags & WIN_HELP_GLOS_BIT)
							Post_Hilight = 3;
							else
							Post_Hilight = 2;
					}

					/*
                    **  Encode the topic index and add a topic link sequence
                    **  and an EAS2 or EAS3 sequence to the current word
                    */

					topic = WIN_HELP_LINK_ENCODE (topic);
					X_STD2(&topic);

					Word [Word_Bytes++] = WIN_ESC_CHAR;
					Word [Word_Bytes++] = WIN_ESC_LINK;
					Word [Word_Bytes++] = (unsigned char) (topic & 0xff);
					Word [Word_Bytes++] = (unsigned char) (topic >> 8);

					Word [Word_Bytes++] = WIN_ESC_CHAR;
					Word [Word_Bytes++] = (unsigned char) (WIN_ESC_EAS_LO +
					    Post_Hilight);
					X_LCL2(&topic);
				}
				break; /* topic link */

				/*
	            **  Hilight subsequent
	            */

			case 'S':
				/*
                **  If we're not hilighting, this is the first \s;
                **  If we are hilighting, this is the closing \s;
                **  Otherwise, we're in a topic link, so display a message
                **  and ignore this \s.
                */

				if (Post_Hilight == 0)
					Post_Hilight = 1;
				else if (Post_Hilight == 1)
					Post_Hilight = 0;
					else
				{
					fprintf (stderr,
						"\n(%d) Warning - Mismatched \\s sequence\n",
					    Line_Number);
					break;
				}
				Word [Word_Bytes++] = WIN_ESC_CHAR;
				Word [Word_Bytes++] = (unsigned char)
						(WIN_ESC_EAS_LO + Post_Hilight);
				break;

				/*
	            **  Backslash character
	            */

			case '\\':
				/*
                **  Add a backslash to the current word
                */

				Word [Word_Bytes++] = '\\';
				++Word_Size;
				break;

				/*
	            **  Any other character: ignore
	            */
			}
			escape = FALSE;
		}

		else if (ignore && c != '\\')
		{
		}

		/*
        **  Else, not in an escape sequence
        */

		else
		{
			switch (c)
			{
				/*
	            **  End of line
	            */

			case '\n':
				/*
                **  If the paragraph is empty, just write a blank line
                */

				if (Parastart)
					Terminate_Line ();

				/*
                **  Otherwise, this is a word break
                */

				else
				{
					/*
                    **  Write out the current word, if any, and remember if
                    **  it ends with a period
                    */

					period = (Word_Size > 0  &&  Word[Word_Bytes - 1] == '.');
					Flush_Word ();

					/*
                    **  Convert the newline to a space character, two spaces
                    **  if we just scanned a period
                    */

					if (period)
						Write_Space ();
					Write_Space ();
				}
				break; /* case end of line */

				/*
	            **  Space
	            */

			case ' ':
				/*
                **  Write out and clear the current word, if any
                */

				Flush_Word ();

				/*
                **  Write a space character
                */

				Write_Space ();
				break; /* space */

				/*
	            **  Backslash: start of an escape sequence
	            */

			case '\\':
				escape = TRUE;
				break;

				/*
	            **  All other characters: accumulate into the current word
	            */

			default:
				Word [Word_Bytes++] = (unsigned char) c;
				++Word_Size;
				Parastart = FALSE;      /* no longer at the start of a para */
				break;
			}
		}
	}
} /* Scan_Text */


/*.
******************************************************************************
**
**  function -  Pass2:
**
**  desc -      Second pass through the source help text file
**
**              Generate the help file
**
**  entry -     globals:
**              Topic_Count
**              Source_File         may point anywhere
**              Help_File           point to beginning of file
**
**  exit -      globals:
**              Source_File         points to end of file
**              Help_File
**
**  notes -     If an error occurs, a message is displayed and the program
**              terminates.
**
******************************************************************************
*/

void     Pass2 (void)

{
	unsigned char        linebuf [MAX_SOURCE_LINE];
	unsigned char        symbol [MAX_SYMBOL];
	unsigned char        *cptr;
	unsigned char        *symptr;
	HELP_HDR    header;
	TOPSYM      *topsym;
	int         topic_index;


	if (verbose)
		printf ("== Pass Two == ");

	/*
    **  Build and write the help file header
    */

	memset (&header, 0, sizeof (header));
	header.signature = WIN_HELP_SIGNATURE;
	header.topics = Topic_Count;
	X_STD4(&header.signature);
	X_STD2(&header.topics);
	fwrite (&header, sizeof (header), 1, Help_File);
	HELP_FILE_CHECK;

	/*
    **  Seek to the start of the help text and write a zero byte.
    **  The help viewer window code in the Window Manager depends on
    **  there being a zero before the very first line of help text
    **  in the help file.
    */

	Topic.text_offset = sizeof (header) + sizeof (Topic) * Topic_Count;
	fseek (Help_File, Topic.text_offset, SEEK_SET);
	fwrite ("\000", 1, 1, Help_File);
	HELP_FILE_CHECK;
	++Topic.text_offset;

	/*
    **  Read through the help source file and write the topic array,
    **  the help text, and the include file
    */

	topic_index = 0;
	while (TRUE)
	{
		/*
        **  Look for the beginning of a topic:
        **  Read lines until a non-blank, non-comment line is encountered
        */

		while (TRUE)
		{
			/*
            **  If end of file, we're done
            */

			if (Get_Source_Line (linebuf) == EOF)
			{
				if (verbose)
					printf ("\n");
				return;
			}

			/*
            **  If this is not a comment, scan past leading whitespace
            */

			if (linebuf [0] != COMMENT_CHAR)
			{
				cptr = linebuf;
				while (WHITESPACE (*cptr))
					++cptr;

				/*
                **  If there's something on this line, it must be the start
                **  of a topic
                */

				if (*cptr != 0)
					break;
			}
		}

		/*
        **  Save the symbolic name for this topic
        */

		symptr = symbol;
		while (*cptr != 0  &&  !SEPARATOR (*cptr)  &&
		    symptr - symbol < MAX_SYMBOL - 1)
			*symptr++ = *cptr++;
		*symptr = 0;

		/*
        **  Read and convert the title and explanatory text
        */

		Scan_Text ();

		/*
        **  Write out the topic array entry
        */

		if ((topsym = Lookup_Symbol((unsigned char *)symbol)) == 0)
		{
			fprintf (stderr,
				"\n(%d) Internal error - Pass2(): Lookup_Symbol() failed ",
			    Line_Number);
			fprintf (stderr, "on %s\n", symbol);
			exit (-1);
		}
		Topic.flags = topsym->flags;
		X_STD4(&Topic.text_offset);
		X_STD4(&Topic.text_lines);
		X_STD4(&Topic.flags);
		fseek (Help_File, (long) sizeof (header) + sizeof (Topic) *
		    topic_index, SEEK_SET);
		fwrite (&Topic, sizeof (Topic), 1, Help_File);
		X_LCL4(&Topic.text_offset);
		X_LCL4(&Topic.text_lines);
		X_LCL4(&Topic.flags);
		HELP_FILE_CHECK;

		/*
        **  Update the help text offset and seek back to the end of
        **  the help text
        */

		Topic.text_offset += Text_Bytes;
		fseek (Help_File, Topic.text_offset, SEEK_SET);

		++topic_index;

		if (verbose)
			printf (".");
	}
} /* Pass2 */
