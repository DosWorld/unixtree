/*****************************************************************************
** FILE NAME:       symbol.c
**
** DESCRIPTION:     Topic Symbol Table Management
**
** IMPLEMENTATION NOTES:
**
**  The topic symbol table is implemented as an externally chained
**  hash table.  A pointer array of arbitrary size points to linked
**  lists of symbol table entries.  A symbol name is converted, by the
**  hashing function Hash_Symbol(), to an index into this pointer array
**  and the associated list (if any) is searched for a matching entry.
**
** void     Sym_Init (void);
** static int      Hash_Symbol (unsigned char *sym);
** static TOPSYM   *Find_Symbol (unsigned char *sym, int *hash_index);
** int     Add_Symbol (unsigned char *sym, int index, unsigned short flags);
** TOPSYM   *Lookup_Symbol (unsigned char *sym);
**
******************************************************************************
** REVISION HISTORY:
**   Thu Jul 27, 1989 - initiated by "Ken Broomfield"
**
*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "hlpmgrif.h"
#include "hlpbld.h"
#include "hlpsymbol.h"


/******************************************************************************
**          FORWARD FUNCTION DECLARATIONS (GENERATED BY MM.EXE)
******************************************************************************/
void     Sym_Init (void);
static int      Hash_Symbol (unsigned char *sym);
static TOPSYM   *Find_Symbol (unsigned char *sym, int *hash_index);
int     Add_Symbol (unsigned char *sym, int index, unsigned short flags);
TOPSYM   *Lookup_Symbol (unsigned char *sym);
/******************************************************************************
**        END OF FORWARD FUNCTION DECLARATIONS (GENERATED BY MM.EXE)
******************************************************************************/

#define SYMBOL_TABLE_SIZE	(1024 * 64)
#define MAX_TABLE_SIZE		(1024 * 128)

/*
**  Topic symbol table
*/
/* hash table - pointers into Sym_Table */
static TOPSYM   *Sym_Hash_Table [SYM_PTR_ARRAY_SIZE];
static unsigned char *Sym_Table;    /* current position in table */
static long     Sym_Table_Free;     /* bytes remaining in table */
static long     Sym_Table_Size = SYMBOL_TABLE_SIZE;     /* bytes rem in tbl */


/*.
******************************************************************************
**
**  function -  Sym_Init:
**
**  desc -      Initialize topic symbol table
**
**  exit -      globals:
**
**  notes -     If a memory allocation error occurs, a message is displayed
**              and the program terminates.
**
******************************************************************************
*/

void     Sym_Init (void)

{
	/*
    **  Allocate all available memory for the topic symbol table
    */

	while (TRUE)
	{
		Sym_Table = (unsigned char *)MALLOC((unsigned)Sym_Table_Size);
		if (Sym_Table == (unsigned char *)NULL && Sym_Table_Size > 1024)
			Sym_Table_Size -= 512;
		else
			break;
	}
	if (Sym_Table == (unsigned char *)NULL)
	{
		fprintf (stderr,
			"\nFatal error - Can't allocate topic symbol table\n");
		exit (-1);
	}
	Sym_Table_Free = Sym_Table_Size;

	/*
    **  Clear the pointer array
    */

	memset (Sym_Hash_Table, 0, sizeof (Sym_Hash_Table));
} /* Sym_Init */


/*.
******************************************************************************
**
**  function -  Hash_Symbol:
**
**  desc -      Convert (via hashing) a symbol name to an index
**              into the topic symbol table
**
**  entry -     sym                 ptr to symbol string
**
**  exit -      index               hash table index for this symbol
**
**  notes -
**
******************************************************************************
*/

static int      Hash_Symbol (unsigned char *sym)

{
	unsigned    index;
	int         count;

	/*
    **  Rotate and exclusive-or characters into the index;
    **  Observe the maximum symbol length limit
    */

	index = 0;
	count = MAX_SYMBOL - 1;
	while (*sym != 0  &&  count > 0)
	{
		index <<= 1;
		/*        index = _rotl (index, 1);*/
		index ^= *sym++;
		--count;
	}

	/*
    **  Adjust the index for proper range
    **  Index must be unsigned, so we don't go negative
    */

	index %= SYM_PTR_ARRAY_SIZE;

	return (index);
} /* Hash_Symbol */


/*.
******************************************************************************
**
**  function -  Find_Symbol:
**
**  desc -      Search for a symbol in the topic symbol table
**
**  entry -     sym                 symbol name to search for
**
**  exit -      *hash_index         hash table index for this entry
**                                  (used only by Add_Symbol when there is
**                                  no match)
**              returns             pointer to topic symbol table entry;
**                                  NULL if no match was found
**
**  notes -     This is a local function shared by Add_Symbol() and
**              Lookup_Symbol().  Lookup_Symbol() is the global
**              function used to look-up symbols in the table.
**
******************************************************************************
*/

static TOPSYM   *Find_Symbol (unsigned char *sym, int *hash_index)

{
	TOPSYM  *entry_ptr;
	unsigned char    *tabsym;
	unsigned char    *target;
	int match;
	int     count;


	/*
    **  Compute the hash table index and fetch the list head pointer
    */

	entry_ptr = Sym_Hash_Table [*hash_index = Hash_Symbol (sym)];

	/*
    **  Search for a match until we reach the end of the list
    */

	while (entry_ptr != (TOPSYM *)NULL)
	{
		/*
        **  Compare symbol characters until a terminator or a mismatch
        **  is found
        **
        **  (Because of an atrocity committed by an Intel microprocessor
        **  design team several years ago, we cannot use the C library
        **  string comparison function.)
        */

		target = sym;
		tabsym = (unsigned char *)entry_ptr->name;
		count = MAX_SYMBOL - 1;
		do
		{
			match = (*target == *tabsym);
			++tabsym;
			--count;
		} while (match  &&  *target++ != 0  &&  count > 0);

		/*
        **  If we match, return this entry's index
        */

		if (match)
			return (entry_ptr);

		entry_ptr = entry_ptr->next;
	}

	/*
    **  No match
    */

	return ((TOPSYM *)NULL);
} /* Find_Symbol */


/*.
******************************************************************************
**
**  function -  Add_Symbol:
**
**  desc -      Add a symbol to the topic symbol table
**
**  entry -     sym                 ptr to symbol string
**              index               associated topic index
**              flags               topic flags
**
**  exit -      returns             TRUE if okay, FALSE if symbol already
**                                  exists in table
**
**  notes -     If the symbol table overflows, a message is displayed and
**              the program terminates.
**
******************************************************************************
*/

int  Add_Symbol (unsigned char *sym, int index, unsigned short flags)

{
	int     hash_index;
	TOPSYM  *entry_ptr;
	int     entry_size;
	int     sym_len;
	unsigned char    *realloc_ptr;
	long    table_size;


	/*
    **  If this symbol is already in the table, return error
    */

	if (Find_Symbol (sym, &hash_index))
		return (FALSE);

	/*
    **  Get the length of the symbol; limit its length
    */

	sym_len = strlen ((char *)sym);
	if (sym_len > MAX_SYMBOL - 1)
		sym_len = MAX_SYMBOL - 1;

	/*
    **  Calculate the size of this table entry - it varies based on
    **  the size of the symbol string;
    **  allocate space for the entry
    **  in the symbol table
    */

	entry_size = TOPSYM_SIZE + sym_len;
	entry_size = ((entry_size + 7) / 8) * 8;	/* round up to multiple of 8 */
	entry_ptr = (TOPSYM *)Sym_Table;
	if (Sym_Table_Free < entry_size)
	{
		if ((table_size = Sym_Table_Size + SYMBOL_TABLE_SIZE) > MAX_TABLE_SIZE)
		{
			if ((table_size = MAX_TABLE_SIZE) < Sym_Table_Size)
			{
				fprintf (stderr,
					"\nFatal error - Topic symbol table overflow.\n");
				exit (-1);
			}
		}
		while ((realloc_ptr = (unsigned char *)REALLOC(Sym_Table,
			(unsigned)table_size)) == (unsigned char *)NULL
		    && table_size > Sym_Table_Size)
		{
			table_size -= 512;
		}
		if (table_size <= Sym_Table_Size)
		{
			fprintf (stderr,
				"\nFatal error - Can't allocate topic symbol table\n");
			exit (-1);
		}
		Sym_Table = realloc_ptr;
		Sym_Table_Free = table_size - Sym_Table_Size;
		Sym_Table_Size = table_size;
	}
	Sym_Table += entry_size;
	Sym_Table_Free -= entry_size;

	/*
    **  If we've run out of space in the table, croak
    */

	if (Sym_Table_Free < 0)
	{
		fprintf (stderr, "\nFatal error - Topic symbol table overflow.\n");
		exit (-1);
	}

	/*
    **  Copy the symbol name and index to the table and link it into
    **  the start of this linked list
    */
	strcpy(entry_ptr->name, (char *)sym);
#if 0
	movedata ((unsigned) ((long) ((unsigned char *) sym) >> 16), (unsigned)sym,
	    (unsigned) ((long) entry_ptr->name >> 16),
	    (unsigned) entry_ptr->name, sym_len + 1);
#endif
	entry_ptr->index = index;
	entry_ptr->flags = flags;
	entry_ptr->next = Sym_Hash_Table [hash_index];
	Sym_Hash_Table [hash_index] = entry_ptr;

	return (TRUE);
} /* Add_Symbol */


/*.
******************************************************************************
**
**  function -  Lookup_Symbol:
**
**  desc -      Look up a symbol in the topic symbol table
**
**  entry -     sym                 ptr to symbol string
**
**  exit -      returns             pointer to topic symbol table entry;
**                                  NULL if no match was found
**
**  notes -
**
******************************************************************************
*/

TOPSYM   *Lookup_Symbol (unsigned char *sym)

{
	int     hash_index;

	return (Find_Symbol (sym, &hash_index));
} /* Lookup_Symbol */
