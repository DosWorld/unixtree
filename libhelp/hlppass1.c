/*****************************************************************************
** FILE NAME:       pass1.c
**
** DESCRIPTION:     First Pass Through Source Help File
**
** int      Get_Source_Line (unsigned char *buffer);
** int      Get_Source_Char (void);
** void     Pass1 (void);
**
******************************************************************************
** REVISION HISTORY:
**   Wed May 31, 1989 - initiated by Ken Broomfield
**
**  8/14/89     KWB     Added hypertext linkage capability.
**
*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "hlpmgrif.h"
#include "hlpbld.h"
#include "hlppass1.h"
#include "hlpsymbol.h"

/******************************************************************************
**          FORWARD FUNCTION DECLARATIONS (GENERATED BY MM.EXE)
******************************************************************************/
int      Get_Source_Line (unsigned char *buffer);
int      Get_Source_Char (void);
void     Pass1 (void);
/******************************************************************************
**        END OF FORWARD FUNCTION DECLARATIONS (GENERATED BY MM.EXE)
******************************************************************************/

/*.
******************************************************************************
**
**  function -  Get_Source_Line:
**
**  desc -      Read the next entire line from the source file
**
**  entry -     buffer              ptr to buffer
**
**              globals:
**              Source_File
**
**  exit -      returns             length of line or EOF if end of file
**              *buffer             text line, terminated by a zero,
**                                  containing no end of line '\n' characters
**
**              globals:
**              Line_Number         the number of the line just read
**
**  notes -     The line buffer is assumed to be of size MAX_SOURCE_LINE.
**
**              If the line being read is too big or an I/O error occurs,
**              a message is displayed and the program terminates.
**
******************************************************************************
*/

int      Get_Source_Line (unsigned char *buffer)

{
	int     len;


	/*
    **  Anyone who needs this code explained to them shouldn't even
    **  be reading it in the first place
    */

	++Line_Number;
	Last_Eol = TRUE;

	if (fgets ((char *)buffer, MAX_SOURCE_LINE, Source_File) == (char *)NULL)
	{
		if (ferror (Source_File))
		{
			fprintf (stderr, "\n(%d) Error - File error reading source file\n",
			    Line_Number);
			exit (-1);
		}
		else
			return (EOF);
	}

	len = strlen ((char *)buffer);
	if (buffer [len - 1] == '\n')
		buffer [--len] = 0;
		else
	{
		fprintf (stderr, "(%d) Error - Source line too long\n", Line_Number);
		exit (-1);
	}
	return (len);
} /* Get_Source_Line */


/*.
******************************************************************************
**
**  function -  Get_Source_Char:
**
**  desc -      Read the next character from the source file
**
**  entry -     globals:
**              Source_File
**
**  exit -      returns             character or EOF if end of file
**
**              globals:
**              Line_Number         updated
**
**  notes -
**
******************************************************************************
*/

int      Get_Source_Char (void)

{
	int     c;


	if (Last_Eol)
		++Line_Number;
	c = fgetc (Source_File);
	if (ferror (Source_File))
	{
		fprintf (stderr, "\n(%d) Error - File error reading source file\n",
		    Line_Number);
		exit (-1);
	}
	Last_Eol = (c == '\n');
	return (c);
} /* Get_Source_Char */


/*.
******************************************************************************
** FUNCTION:    strcmp_i()
**
** DESCRIPTION: This function compares 1 string to another, w/o case
**                  sensitivity.
**
** ENTRY:       see strcmp()
**
** EXIT:        see strcmp()
**
** NOTES:       NONE
**
*****************************************************************************/
static int strcmp_i(unsigned char *string1, unsigned char *string2)
{
	int i;
	unsigned char ch1, ch2;

	i = 0;
	ch1 = string1[i];
	ch2 = string2[i];
	if (isascii(ch1))
	{
		if (isalpha(ch1) && islower(ch1))
		{
			ch1 = toupper(ch1);
		}
	}
	if (isascii(ch2))
	{
		if (isalpha(ch2) && islower(ch2))
		{
			ch2 = toupper(ch2);
		}
	}
	while (ch1 == ch2)
	{
		if (string1[i++] == '\0')
		{
			return (0);
		}
		ch1 = string1[i];
		ch2 = string2[i];
		if (isascii(ch1))
		{
			if (isalpha(ch1) && islower(ch1))
			{
				ch1 = toupper(ch1);
			}
		}
		if (isascii(ch2))
		{
			if (isalpha(ch2) && islower(ch2))
			{
				ch2 = toupper(ch2);
			}
		}
	}
	return (ch1 - ch2);
}


/*.
******************************************************************************
**
**  function -  Pass1:
**
**  desc -      First pass through source help text file
**
**              - Build the topic symbol table
**              - Write the include file
**              - Count the number of topics
**
**  entry -     globals:
**              Source_File,
**              Include_File        all point to beginning of file
**
**  exit -      globals:
**              Source_File         points to end of file
**              Topic_Count         set
**              Include_File        complete
**
**  notes -     If an error occurs, a message is displayed and the program
**              terminates.
**
******************************************************************************
*/

void     Pass1 (void)

{
	unsigned char    linebuf [MAX_SOURCE_LINE];
	unsigned char    *cptr;
	int escape;
	unsigned char    *symptr, *flagptr;
	unsigned short   flags;
	int		eol;
	int     spaces;
	int     len;


	if (verbose)
		printf ("-- Pass One -- ");

	/*
    **  Initialize
    */

	Topic_Count = 0;

	/*
    **  Write the include file opening comments
    */

	fprintf (Include_File, "/*\n");
	fprintf (Include_File, "**  %s.h\n", Include_Name);
	fprintf (Include_File, "**\n");
	fprintf (Include_File, "**  Help topic index definitions\n");
	fprintf (Include_File, "**  >>-- This file is generated by hlpbld --<<\n");
	fprintf (Include_File, "*/\n");
	fprintf (Include_File, "\n");
	fprintf (Include_File, "#ifndef LIBHELP_H\n");
	fprintf (Include_File, "#define LIBHELP_H\n");
	fprintf (Include_File, "\n");
	fprintf (Include_File, "#include \"hlpmgrif.h\"\n");
	fprintf (Include_File, "\n");
	INC_FILE_CHECK;

	/*
    **  Read through the entire source file
    */

	while (TRUE)
	{
		/*
        **  Read lines until a non-blank, non-comment line is encountered
        */

		while (TRUE)
		{
			/*
            **  If end of file, we're done
            */

			if (Get_Source_Line (linebuf) == EOF)
			{
				if (verbose)
					printf ("\n");
				goto done;
			}

			/*
            **  If this is not a comment, scan past leading whitespace
            */

			if (linebuf [0] != COMMENT_CHAR)
			{
				cptr = linebuf;
				while (WHITESPACE (*cptr))
					++cptr;

				/*
	            **  If there's something on this line, it must be the start
                **  of a topic
                */

				if (*cptr != 0)
					break;
			}
		}

		/*
        **  If we've already reached the maximum number of topics,
        **  tell them and terminate
        */

		if (Topic_Count == WIN_HELP_MAX_TOPICS)
		{
			fprintf (stderr, "\nError - Too many topics.\n");
			fprintf (stderr,
				"Anyone who would needs this much help is beyond help.\n");
			exit (-1);
		}

		/*
        **  Process the symbol/flags line
        */

		/*
        **  Scan for the end of the symbolic topic name
        */

		symptr = cptr;                  /* start of symbol */
		while (!(eol = (*cptr == 0))  &&  !SEPARATOR (*cptr))
			++cptr;
		*cptr = 0;                      /* terminate symbol */
		++cptr;

		/*
        **  Process the rest of the symbol/flags line: the flags
        */

		flags = WIN_WF_HVCENTER_MASK;        /* default flags */
		while (!eol)
		{
			/*
            **  Scan for the start of this flag
            */

			while (!(eol = (*cptr == 0))  &&  SEPARATOR (*cptr))
				++cptr;

			/*
            **  Scan for the end of this flag
            */

			if (!eol)
			{
				flagptr = cptr;
				while (!(eol = (*cptr == 0))  &&  !SEPARATOR (*cptr))
					++cptr;
				*cptr++ = 0;

				/*
                **  Process the flag
                */

				if (strcmp_i (flagptr, (unsigned char *)"LEFT") == 0)
					flags = (flags & ~WIN_WF_HCENTER_BIT) | WIN_WF_LEFT_BIT;

				else if (strcmp_i (flagptr, (unsigned char *)"HCENTER") == 0)
					flags |= WIN_WF_HCENTER_BIT;

				else if (strcmp_i (flagptr, (unsigned char *)"RIGHT") == 0)
					flags = (flags & ~WIN_WF_HCENTER_BIT) | WIN_WF_RIGHT_BIT;

				else if (strcmp_i (flagptr, (unsigned char *)"TOP") == 0)
					flags = (flags & ~WIN_WF_VCENTER_BIT) | WIN_WF_TOP_BIT;

				else if (strcmp_i (flagptr, (unsigned char *)"VCENTER") == 0)
					flags |= WIN_WF_VCENTER_BIT;

				else if (strcmp_i (flagptr, (unsigned char *)"BOTTOM") == 0)
					flags = (flags & ~WIN_WF_VCENTER_BIT) | WIN_WF_BOTTOM_BIT;

				else if (strcmp_i (flagptr, (unsigned char *)"GLOS") == 0)
					flags |= WIN_HELP_GLOS_BIT;

				else
					fprintf (stderr,
					"\n(%d) Warning - Unrecognized flag '%s' for topic '%s'\n",
					    Line_Number, flagptr, symptr);
			}
		}

		/*
        **  Add this symbol to the topic symbol table;
        **  If it already exists, give them a warning
        */

		if (!Add_Symbol ((unsigned char *)symptr, Topic_Count, flags))
			fprintf (stderr,
				"\n(%d) Warning - Duplicate symbolic topic name: %s\n",
			    Line_Number, symptr);

		/*
        **  Unless this is a glossary topic, write the symbolic name to
        **  the include file.  Do not truncate it per hlpbld's length limit
        */

		if ((flags & WIN_HELP_GLOS_BIT) == 0)
		{
			fprintf (Include_File, "#define %s ", symptr);
			INC_FILE_CHECK;
			spaces = 20 - strlen ((char *)symptr);
			while (spaces-- > 0)
			{
				fputc (' ', Include_File);
				INC_FILE_CHECK;
			}
			fprintf (Include_File, "%5d    ", Topic_Count);
			INC_FILE_CHECK;
		}

		/*
        **  Read in the title text line - check its length
        */

		if ((len = Get_Source_Line (linebuf)) == EOF)
		{
			fprintf (stderr,
				"(%d) Error - Unexpected end of file\n", Line_Number);
			exit (-1);
		}
		if (len + 1 > WIN_HELP_MAX_TITLE)
		{
			fprintf (stderr,
			    "\n(%d) Warning - Title '%s' too long - truncated\n",
			    Line_Number, linebuf);
			len = WIN_HELP_MAX_TITLE - 1;
			linebuf [len] = 0;
		}

		/*
        **  Append the title as a comment to each include file line
        */

		if ((flags & WIN_HELP_GLOS_BIT) == 0)
		{
			fprintf (Include_File, "/* %s */\n", linebuf);
			INC_FILE_CHECK;
		}

		/*
        **  Scan for the end of this topic: the \e sequence
        */

		while (Get_Source_Line (linebuf) != EOF)
		{
			/*
            **  If this isn't a comment line, scan it for \e
            */

			escape = FALSE;
			cptr = linebuf;
			if (*cptr != COMMENT_CHAR)
			{
				while (*cptr != 0)
				{
					if (escape)
					{
						if (toupper (*cptr) == 'E')
							break;
						escape = FALSE;
					}
					else
						escape = (*cptr == '\\');
					++cptr;
				}
			}
			if (escape  &&  toupper (*cptr) == 'E')
				break;
		}

		++Topic_Count;

		if (verbose)
			printf (".");
	}

done:
	fprintf (Include_File, "\n");
	fprintf (Include_File, "#endif /* LIBHELP_H */\n");
} /* Pass1 */
